import os
import glob
from typing import Optional, List

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_community.vectorstores import Chroma
from langchain_community.document_loaders import PyPDFLoader
from langchain.chains import RetrievalQA

from langchain_openai import ChatOpenAI, OpenAIEmbeddings

# You can use this section to suppress warnings generated by your code:
def warn(*args, **kwargs):
    pass
import warnings
warnings.warn = warn
warnings.filterwarnings('ignore')

from dotenv import load_dotenv, find_dotenv
_ = load_dotenv(find_dotenv()) # read local .env file

OPENAI_API_KEY  = os.environ['OPENAI_API_KEY']

# Configuration
PDF_FOLDER = "pdfs"  # Folder containing PDF files

# Pydantic models for request/response
class QueryRequest(BaseModel):
    query: str

class QueryResponse(BaseModel):
    answer: str
    success: bool
    message: Optional[str] = None
    sources: Optional[List[str]] = None

# Global variables for the loaded vector database
vectordb = None
qa_chain = None

# Initialize FastAPI app
app = FastAPI(
    title="PDF QA API",
    description="Ask questions about pre-loaded PDF documents",
    version="1.0.0"
)

## LLM
def get_llm():
    openai_llm = ChatOpenAI(
                model_name="gpt-5-mini", #"gpt-3.5-turbo",  # Fixed model name
                openai_api_key=OPENAI_API_KEY,
                temperature=0.5,
                max_tokens=512,  # Increased token limit for better responses
            )
    return openai_llm

## Document loader for multiple PDFs
def load_pdfs_from_folder(folder_path: str):
    """Load all PDF files from the specified folder"""
    if not os.path.exists(folder_path):
        print(f"Warning: PDF folder '{folder_path}' does not exist. Creating it...")
        os.makedirs(folder_path)
        return []
    
    pdf_files = glob.glob(os.path.join(folder_path, "*.pdf"))
    
    if not pdf_files:
        print(f"Warning: No PDF files found in '{folder_path}' folder")
        return []
    
    print(f"Found {len(pdf_files)} PDF files: {[os.path.basename(f) for f in pdf_files]}")
    
    all_documents = []
    for pdf_file in pdf_files:
        try:
            print(f"Loading: {os.path.basename(pdf_file)}")
            loader = PyPDFLoader(pdf_file)
            documents = loader.load()
            
            # Add source information to each document
            for doc in documents:
                doc.metadata['source_file'] = os.path.basename(pdf_file)
            
            all_documents.extend(documents)
        except Exception as e:
            print(f"Error loading {pdf_file}: {str(e)}")
    
    print(f"Total documents loaded: {len(all_documents)}")
    return all_documents



## Text splitter
def text_splitter(data):
    text_splitter = RecursiveCharacterTextSplitter(
        chunk_size=1000,
        chunk_overlap=50,
        length_function=len,
    )
    chunks = text_splitter.split_documents(data)
    return chunks



## Embedding model
def get_embedding():
    openai_embedding = OpenAIEmbeddings(
        model="text-embedding-ada-002",
        openai_api_key=OPENAI_API_KEY
    )
    return openai_embedding


## Vector db
def vector_database(chunks):
    embedding_model = get_embedding()
    vectordb = Chroma.from_documents(chunks, embedding_model)
    return vectordb

## open the file and load the document
# with open("A-Comprehensive-Review-of-Low-Rank-Adaptation-in-Large-Language-Models-for-Efficient-Parameter-Tuning-1.pdf", "rb") as f:
    # doc = document_loader(f)

## split document into chunks
# chunks = text_splitter(doc)

# vector_db = vector_database(chunks);

## Retriever setup for all documents
def initialize_vector_database():
    """Initialize vector database with all PDFs from the folder"""
    global vectordb, qa_chain
    
    # Load all PDF documents
    documents = load_pdfs_from_folder(PDF_FOLDER)
    
    if not documents:
        print("No documents loaded. Vector database will be empty.")
        vectordb = None
        qa_chain = None
        return
    
    # Split documents into chunks
    chunks = text_splitter(documents)
    
    # Create vector database
    vectordb = vector_database(chunks)
    
    # Create QA chain
    llm = get_llm()
    retriever = vectordb.as_retriever()
    qa_chain = RetrievalQA.from_chain_type(
        llm=llm, 
        chain_type="stuff", 
        retriever=retriever, 
        return_source_documents=True
    )
    
    print("Vector database initialized successfully!")

def get_available_documents():
    """Get list of available PDF documents"""
    if not os.path.exists(PDF_FOLDER):
        return []
    
    pdf_files = glob.glob(os.path.join(PDF_FOLDER, "*.pdf"))
    return [os.path.basename(f) for f in pdf_files]

## QA Chain - simplified for pre-loaded documents
def query_documents(query: str):
    """Query the pre-loaded documents"""
    global qa_chain
    
    try:
        print(f"Received query: '{query}'")
        
        # Check if documents are loaded
        if qa_chain is None:
            return {
                "answer": "No documents are loaded. Please ensure PDF files are in the 'pdfs' folder and restart the application.",
                "sources": []
            }
        
        if not query or query.strip() == "":
            return {
                "answer": "Please enter a question.",
                "sources": []
            }
        
        print("Querying documents...")
        # Get response with source documents
        response = qa_chain.invoke(query.strip())
        print(f"Raw response: {response}")
        
        # Extract answer
        if isinstance(response, dict) and 'result' in response:
            answer = response['result']
            source_docs = response.get('source_documents', [])
        else:
            answer = str(response)
            source_docs = []
        
        # Extract source files
        sources = []
        if source_docs:
            sources = list(set([doc.metadata.get('source_file', 'Unknown') for doc in source_docs]))
        
        print(f"Final answer: '{answer}'")
        print(f"Sources: {sources}")
        
        # Make sure answer is not empty
        if not answer or answer.strip() == "":
            return {
                "answer": "I couldn't find a relevant answer in the documents. Please try rephrasing your question.",
                "sources": sources
            }
        
        return {
            "answer": answer,
            "sources": sources
        }
        
    except Exception as e:
        error_msg = f"Error processing your request: {str(e)}"
        print(f"Error occurred: {error_msg}")
        return {
            "answer": error_msg,
            "sources": []
        }

# FastAPI Endpoints

@app.get("/")
async def root():
    """Root endpoint with API information"""
    available_docs = get_available_documents()
    return {
        "message": "PDF QA API",
        "description": "Ask questions about pre-loaded PDF documents",
        "available_documents": available_docs,
        "total_documents": len(available_docs),
        "endpoints": {
            "/query": "POST - Ask a question about the documents",
            "/documents": "GET - List available documents",
            "/health": "GET - Health check"
        }
    }

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    available_docs = get_available_documents()
    return {
        "status": "healthy", 
        "message": "API is running",
        "documents_loaded": len(available_docs),
        "vector_db_initialized": qa_chain is not None
    }

@app.get("/documents")
async def list_documents():
    """List all available PDF documents"""
    available_docs = get_available_documents()
    return {
        "documents": available_docs,
        "total": len(available_docs),
        "folder": PDF_FOLDER
    }

@app.post("/query", response_model=QueryResponse)
async def query_pdf_documents(request: QueryRequest):
    """
    Ask a question about the pre-loaded PDF documents
    """
    try:
        # Validate query
        if not request.query or request.query.strip() == "":
            raise HTTPException(
                status_code=400, 
                detail="Query cannot be empty"
            )
        
        # Process the query
        result = query_documents(request.query.strip())
        
        return QueryResponse(
            answer=result["answer"],
            success=True,
            message="Query processed successfully",
            sources=result["sources"]
        )
                
    except HTTPException:
        raise  # Re-raise HTTP exceptions
    except Exception as e:
        raise HTTPException(
            status_code=500, 
            detail=f"Internal server error: {str(e)}"
        )

# Startup event to initialize vector database
@app.on_event("startup")
async def startup_event():
    """Initialize the vector database on startup"""
    print("Initializing PDF QA API...")
    initialize_vector_database()
    print("API startup complete!")

# Run the FastAPI app
if __name__ == "__main__":
    import uvicorn
    print("Starting PDF QA FastAPI application...")
    
    # Ensure PDF folder exists
    if not os.path.exists(PDF_FOLDER):
        os.makedirs(PDF_FOLDER)
        print(f"Created PDF folder: {PDF_FOLDER}")
        print(f"Please add your PDF files to the '{PDF_FOLDER}' folder and restart the application.")
    
    uvicorn.run(
        app,
        host="127.0.0.1",
        port=7680,
        reload=False,  # Disabled reload to prevent reinitializing vector DB
        log_level="info"
    )